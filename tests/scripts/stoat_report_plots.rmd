---
title: "Stoat Report (08/2025)"
output: pdf_document
---

# Stoat in a nutshell

STOAT is a versatile GWAS (Genome-Wide Association Study) tool designed to work with 
pangenome graphs.

It supports binary phenotypes both with and without covariates: 
using Fisherâ€™s exact test or Chi-squared test when no covariates are present, 
and logistic regression when covariates are included. 

For quantitative traits, STOAT performs linear regression, again with or without covariates. 
Additionally, it supports eQTL analysis, enabling association testing between
genetic variants and gene expression levels. 

It containt 2 modes : 
- VCF : that will take VCF file in input and test snarl variant in it
- Graph : that will test snarl directly on the pangenome graph

## Stoat version 0.2.0 (08/2025)

- stoat :
  - Cartoon update : added stoat graph
  - Unify format output (position, snarl_id, type)
- stoat vcf :
  - Linear regression : Correction for the near perfect collinearity case by merging same column toghever.
  - Logistic regression : Correction of the output format
  - Other correction : fix snarl paths parsing, fix eqtl parsing format file (case handlegraph too big)
- stoat graph :
  - ...

```{r setup, message=FALSE, warning=FALSE}
library(ggplot2)
library(readr)
library(dplyr)
library(tidyr)
library(CMplot)
library(stringr)

utils::globalVariables(c("Expected", "Observed"))

# ---- File paths ----
file_list <- list(
  binary_snarl = "/home/mbagarre/Bureau/stoat/output_binary/snarl_analyse.tsv",
  binary_freq = "/home/mbagarre/Bureau/stoat/data/binary/pg.snarls.freq.tsv",
  binary_vcf = "/home/mbagarre/Bureau/stoat/output_binary/binary_table_vcf.tsv",
  binary_covar_vcf = "/home/mbagarre/Bureau/stoat/output_binary_covar/binary_table_vcf.tsv",

  quantitative_snarl = "/home/mbagarre/Bureau/stoat/output_quantitative/snarl_analyse.tsv",
  quantitative_freq = "/home/mbagarre/Bureau/stoat/data/quantitative/pg.snarls.freq.tsv",
  quantitative_vcf = "/home/mbagarre/Bureau/stoat/output_quantitative/quantitative_table_vcf.tsv",
  quantitative_covar_vcf = "/home/mbagarre/Bureau/stoat/output_quantitative_covar/quantitative_table_vcf.tsv",

  eqtl_snarl = "/home/mbagarre/Bureau/stoat/output_eqtl/snarl_analyse.tsv",
  eqtl_freq = "/home/mbagarre/Bureau/stoat/data/eqtl/pg.snarls.freq.tsv",
  eqtl_vcf = "/home/mbagarre/Bureau/stoat/output_eqtl/eqtl_table_vcf.tsv",
  eqtl_covar_vcf = "/home/mbagarre/Bureau/stoat/output_eqtl_covar/eqtl_table_vcf.tsv",

  binary_graph = "/home/mbagarre/Bureau/stoat/output_binary_graph/binary_table_graph.tsv"
)

# ---- Helper functions ----

# Read and clean table
read_stoat <- function(path) {
  df <- read_tsv(path, show_col_types = FALSE)
  if ("#CHR" %in% names(df)) names(df)[names(df) == "#CHR"] <- "CHR"
  if ("START_POS" %in% names(df) && !"POS" %in% names(df)) df$POS <- df$START_POS
  return(df)
}

# Split snarl string on ">" or "<", remove empty elements
split_snarl <- function(input_str) {
  parts <- unlist(strsplit(input_str, "[><]"))
  parts <- parts[parts != ""]  # Filter out empty strings
  return(as.character(parts))  # Keep it as string like in Python version
}

process_file <- function(freq_file, threshold = 0.2) {
  df <- read.delim(freq_file, sep = "\t", stringsAsFactors = FALSE)
  
  freq_path_list <- character()
  true_labels <- integer()
  list_diff <- numeric()
  
  for (i in seq(1, nrow(df) - 1, by = 2)) {
    row_1 <- df[i, ]
    row_2 <- df[i + 1, ]
    
    diff <- abs(row_1$freq - row_2$freq)
    
    # If group freq diff > threshold, then true label is 0, else 1
    label <- ifelse(diff > threshold, 0, 1)
    
    path <- paste0(as.integer(row_1$start_node), "_", as.integer(row_1$next_node))
    
    freq_path_list <- c(freq_path_list, path)
    true_labels <- c(true_labels, label)
    list_diff <- c(list_diff, diff)
  }
  
  return(list(freq_path_list = freq_path_list, true_labels = true_labels, list_diff = list_diff))
}

check_valid_snarl <- function(start_node_1, next_node_1, start_node_2, next_node_2, snarl_list) {
  # First condition: start nodes must match
  if (start_node_1 != start_node_2) {
    stop("start_node_1 != start_node_2")
  }
  
  contains_first_pair <- FALSE
  contains_second_pair <- FALSE
  
  for (path in snarl_list) {
    # Extract all numbers from the path string
    decomposed_path <- as.integer(unlist(regmatches(path, gregexpr("\\d+", path))))
    
    if (start_node_1 %in% decomposed_path && next_node_1 %in% decomposed_path) {
      contains_first_pair <- TRUE
    }
    
    if (start_node_2 %in% decomposed_path && next_node_2 %in% decomposed_path) {
      contains_second_pair <- TRUE
    }
    
    if (contains_first_pair && contains_second_pair) {
      return(TRUE)
    }
  }
  
  return(contains_first_pair && contains_second_pair)
}


match_snarl <- function(freq_path_list, true_labels, list_diff, p_value_file, paths_file, save_sv_snarl = NULL, type_) {
  # Load data
  p_value_df <- read_tsv(p_value_file, show_col_types = FALSE)
  paths_df <- read_tsv(paths_file, show_col_types = FALSE) %>%
    select(SNARL, PATHS)

  # Merge on SNARL
  p_value_df <- left_join(p_value_df, paths_df, by = "SNARL")

  # Split SNARL
  snarl_split <- str_split_fixed(p_value_df$SNARL, "_", 2)
  snarl_start <- as.integer(snarl_split[,1])
  snarl_end <- as.integer(snarl_split[,2])

  # Outputs
  predicted_labels_10_2 <- c()
  predicted_labels_10_5 <- c()
  predicted_labels_10_8 <- c()
  cleaned_true_labels <- c()
  clean_list_diff <- c()
  pvalue_list <- c()
  num_sample <- c()
  snarl_name <- c()

  step <- 2
  for (i in seq(1, length(freq_path_list) - 1, by = step)) {
    nodes1 <- as.integer(str_split(freq_path_list[[i]], "_")[[1]])
    nodes2 <- as.integer(str_split(freq_path_list[[i + 1]], "_")[[1]])
    start_node_1 <- nodes1[1]; next_node_1 <- nodes1[2]
    start_node_2 <- nodes2[1]; next_node_2 <- nodes2[2]

    # Vectorized filtering
    match_mask <- ((snarl_end <= start_node_1 & snarl_start >= next_node_1) |
                   (snarl_start <= start_node_1 & snarl_end >= next_node_1))
    matched_rows <- p_value_df[match_mask, ]

    if (nrow(matched_rows) > 0) {
      if (!is.null(save_sv_snarl)) {
        matched_rows <- matched_rows %>% filter(SNARL %in% save_sv_snarl)
      }

      for (row_idx in 1:nrow(matched_rows)) {
        matched <- matched_rows[row_idx, ]

        path_list <- str_split(matched$PATHS, ",")[[1]]
        if (check_valid_snarl(start_node_1, next_node_1, start_node_2, next_node_2, path_list)) {
          p_val <- matched$P_ADJUSTED

          if (type_ == "binary") {
            group_paths <- matched$GROUP_PATHS
            if (!is.na(group_paths) && group_paths != "") {
              parts <- str_split(group_paths, ",")[[1]]
              allele_num <- sum(as.integer(str_extract(parts, "(?<=:)\\d+")), na.rm = TRUE)
            } else {
              allele_num <- 200
            }
          } else if (type_ == "quantitative") {
            group_paths <- matched$ALLELE_PATHS
            if (!is.na(group_paths) && group_paths != "") {
              allele_num <- sum(as.integer(str_split(group_paths, ",")[[1]]), na.rm = TRUE)
            } else {
              allele_num <- 200
            }
          } else {
            stop("type_ must be 'binary' or 'quantitative'")
          }

          snarl_name <- c(snarl_name, matched$SNARL)
          predicted_labels_10_2 <- c(predicted_labels_10_2, ifelse(p_val < 0.01, 0, 1))
          predicted_labels_10_5 <- c(predicted_labels_10_5, ifelse(p_val < 1e-5, 0, 1))
          predicted_labels_10_8 <- c(predicted_labels_10_8, ifelse(p_val < 1e-8, 0, 1))
          cleaned_true_labels <- c(cleaned_true_labels, true_labels[i])
          clean_list_diff <- c(clean_list_diff, list_diff[i])
          pvalue_list <- c(pvalue_list, p_val)
          num_sample <- c(num_sample, allele_num)
        }
      }
    }
  }

  return(list(
    predicted_labels_10_2 = predicted_labels_10_2,
    predicted_labels_10_5 = predicted_labels_10_5,
    predicted_labels_10_8 = predicted_labels_10_8,
    cleaned_true_labels = cleaned_true_labels,
    clean_list_diff = clean_list_diff,
    pvalue_list = pvalue_list,
    num_sample = num_sample,
    snarl_name = snarl_name
  ))
}


# QQ plot with customizable column and subtitle
qq_plot <- function(df, col, subtitle = "") {
  if (!col %in% names(df)) return(NULL)

  pvec <- df[[col]]
  observed <- sort(pvec[!is.na(pvec)])
  expected <- -log10(ppoints(length(observed)))
  observed_log <- -log10(observed)
  data <- data.frame(Expected = expected, Observed = observed_log)
  
  ggplot(data, aes(x = Expected, y = Observed)) +
    geom_point(size = 1, alpha = 0.5) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
    labs(
      title = paste("QQ Plot of", col, subtitle),
      x = "Expected -log10(P)", y = "Observed -log10(P)"
    ) +
    theme_bw()
}

manhattan_plot <- function(df, subtitle = "", ...) {
  p_cols <- c(...)
  
  if (!all(c("CHR", "POS") %in% names(df))) {
    message("Skipping Manhattan plot: missing required columns 'CHR' or 'POS'.")
    return(NULL)
  }
  
  # If no P columns specified, default to "P" if exists
  if (length(p_cols) == 0) {
    if ("P" %in% names(df)) {
      p_cols <- "P"
    } else {
      message("No P-value column specified or found. Skipping plot.")
      return(NULL)
    }
  }
  
  # Convert CHR to numeric for plotting
  df$CHR_numeric <- as.numeric(as.factor(df$CHR))
  
  # Keep only relevant columns
  df_plot <- df %>%
    select(CHR_numeric, POS, all_of(p_cols)) %>%
    pivot_longer(cols = all_of(p_cols), names_to = "P_column", values_to = "P") %>%
    filter(!is.na(P))
  
  # Plot
  ggplot(df_plot, aes(x = POS, y = -log10(P), color = P_column)) +
    geom_point(alpha = 0.6) +
    theme_bw() +
    labs(
      title = paste("Manhattan plot", subtitle),
      x = "Position (BP)",
      y = "-log10(P)",
      color = "P-value column"
    )
}

# Volcano plot
volcano_plot <- function(df, p_col = "P", beta_col = "BETA", 
                         title = "Volcano Plot Beta vs P-value", subtitle = NULL, 
                         log_y = TRUE, point_alpha = 0.6, point_color = "blue") {
  
  # Check required columns
  if (!all(c(beta_col, p_col) %in% names(df))) {
    message(sprintf("Skipping Volcano plot: '%s' or '%s' not found.", beta_col, p_col))
    return(NULL)
  }
  
  # Compute -log10(P)
  df$logP <- -log10(df[[p_col]])
  
  # Plot
  p <- ggplot(df, aes_string(x = beta_col, y = "logP")) +
    geom_point(alpha = point_alpha, color = point_color) +
    theme_bw() +
    labs(
      title = title,
      subtitle = subtitle,
      x = paste("Effect Size (", beta_col, ")", sep = ""),
      y = paste("-log10(", p_col, ")", sep = "")
    )
  
  if (log_y) {
    p <- p + scale_y_continuous(trans = "log10")
  }
  
  return(p)
}

# RSQUARE vs BETA plot
rsq_plot <- function(df, rsq_col = "RSQUARE", beta_col = "BETA", 
                     title = "Effect Size vs RSQUARE", subtitle = NULL, 
                     log_x = FALSE, log_y = FALSE, point_alpha = 0.6, point_color = "blue") {
  
  # Check required columns
  if (!all(c(rsq_col, beta_col) %in% names(df))) {
    message(sprintf("Skipping RSQ plot: '%s' or '%s' not found.", rsq_col, beta_col))
    return(NULL)
  }
  
  # Plot
  p <- ggplot(df, aes_string(x = rsq_col, y = beta_col)) +
    geom_point(alpha = point_alpha, color = point_color) +
    theme_bw() +
    labs(
      title = title,
      subtitle = subtitle,
      x = rsq_col,
      y = beta_col
    )
  
  if (log_x) p <- p + scale_x_continuous(trans = "log10")
  if (log_y) p <- p + scale_y_continuous(trans = "log10")
  
  return(p)
}

# Histogram of P-values with custom columns and subtitle
histogram_plot <- function(df, subtitle = "", ...) {
  cols <- c(...)
  if (!all(cols %in% names(df))) return(NULL)

  df_long <- df %>%
    select(all_of(cols)) %>%
    pivot_longer(cols = everything(), names_to = "Type", values_to = "PValue")
  
  ggplot(df_long, aes(x = PValue, fill = Type)) +
    geom_histogram(alpha = 0.6, position = "dodge", bins = 50) +
    theme_bw() +
    labs(
      title = paste("Distribution of P-values", subtitle),
      x = "P-value", y = "Count"
    ) +
    scale_fill_brewer(palette = "Set1")
}

# ---- Run Python verification truth VCF ----
run_verify_truth <- function(freq_file, pvalue_file, paths_file, flag, output_dir) {
  cmd <- paste(
    "python3 /home/mbagarre/Bureau/stoat/tests/scripts/verify_truth.py",
    "--freq", freq_file,
    "--p_value", pvalue_file,
    "--paths", paths_file,
    flag,
    "--output", output_dir
  )
  output <- system(cmd, intern = TRUE)
  return(output)
}

run_scatter_plot_graph <- function(input, output) {
  cmd <- paste(
    "python3 /home/mbagarre/Bureau/stoat/tests/scripts/plot_scatter.py",
    input,
    output
  )
  output <- system(cmd, intern = TRUE)
  return(output)
}

run_histo_plot_graph <- function(input, output) {
  cmd <- paste(
    "python3 /home/mbagarre/Bureau/stoat/tests/scripts/plot_histogram.py",
    input,
    output
  )
  output <- system(cmd, intern = TRUE)
  return(output)
}
```

## Simulation description
We construct 2 simulated dataset (binary and quantitative) each one has its own pangenome graph containing only one chromosome that incorporates variations like SNP, INDEL and complex variant, but the structure base on fork remains the same amoung all simulation. A fork structure can be define as a boundary snarl with only 2 paths that can containt also other fork in it. Once the pangenome graph was constructed, we simulated individual haplotypes by generating sample genomes that traverse different paths within the graph. To introduce phenotype-genotype relationships, we assigned each haplotype to a binary or quantitative phenotype rule simulation

```{r results='asis'}
library(knitr)

# Create the data frame
df <- data.frame(
  Type = c("Binary", "Quantitative"),
  `Number of samples` = c(200, 200),
  `Number of variant type (SNP/INDEL/COMPLEX)` = c("2444/446/158", "2478/382/138"),
  `Number of snarl/paths` = c("1524/3048", "1499/2998"),
  check.names = FALSE
)

# Print as R Markdown table
kable(df, format = "markdown", align = "c")
```

### Binary simulation
200 Samples were divided into two cohorts (100 case and 100 control), each corresponding to a different phenotypic state containing 1000 variations. Each group had a correlated probability of traversing a specific path within snarls. This probability (e.g., 50/50) could be equal between the two cohorts or skewed in favor of one group (e.g., 20/80), simulating an association between variation and phenotype.

```{r show-fork-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/plots/fork.png")
```
Fork representation

### Quantitative simulation
Similar to the binary simulation, 200 samples were divided into two cohorts, with each group having a correlated probability of traversing specific paths within snarls. However, in this case, an additional probability factor was introduced, where the likelihood of passing through a given path was influenced by the individual's phenotype value.

### Eqtl simulation
Here, we simulated 200 samples with 100,000 simple SNP variations and 100 genes. In this simulation, there are no significant variants, everything was generated randomly. The goal was to create a very simple simulation to test STOAT's VCF eQTL implementation.

### Covariate Simulation

Covariates are simulated with no effect. They include **SEX**, **PC1**, **PC2**, and **PC3**.
Each sample has the same values across these covariates: `0`, `25.215`, `75.84`, `45.0`.

### Verifying the Truth Simulation Description

#### Frequency File Description

The **binary** and **quantitative** simulations produce a file containing the following elements:

* The **frequency probability (freq)** of a haplotype, depending on its group, to follow a specific path/edge in a fork.
* The **group** associated with each frequency.
* The **start** and **end** node of the fork.

An identical probability between two groups on the same edge suggests that the edge may appear significant due to randomness, but it will be considered **non-significant** in downstream analysis.
On the other hand, a difference in frequency between the two groups even if small is treated as **significant**.

**Example `freq` file:**

```
start_node	next_node	group	freq
2	        3	        0	    0.53
2	        3	        1	    0.53
2	        4	        0	    0.47
2	        4	        1	    0.47
```

#### Computing Stoat Output with the Frequency File

To assess whether a snarl is correctly identified as significant, we merge the snarl's path information with the frequency probabilities from the `freq` file.

A **correct match** is a snarl that contains **both** start/end node pairs in two **separate paths** (one for each group).

### Graph Information
* A snarl is considered **true** if it contains a fork where **at least one edge** shows a frequency difference between the two groups.
* A snarl is considered **positive** if its **P-value is below 0.01**.

### Binary stoat VCF

```{r binary-vcf}

# Execute verification for binary VCF
binary_output <- run_verify_truth(
  freq_file = file_list$binary_freq,
  pvalue_file = file_list$binary_vcf,
  paths_file = file_list$binary_snarl,
  flag = " -b ",
  output_dir = "../binary_output"
)

cat(binary_output, sep = "\n")

df_binary_vcf <- read_stoat(file_list$binary_vcf)

# Plots
histogram_plot(df=df_binary_vcf, subtitle="Binary [stoat vcf]", "P_FISHER", "P_CHI2", "P_ADJUSTED")
qq_plot(df_binary_vcf, "P_FISHER", subtitle="Binary [stoat vcf]")
qq_plot(df_binary_vcf, "P_CHI2", subtitle="Binary [stoat vcf]")

manhattan_plot(df_binary_vcf, subtitle="Binary [stoat vcf]", "P_CHI2", "P_FISHER", "P_ADJUSTED")
```

```{r show-plot-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/pvalue_interactive.png")
```

```{r show-plot-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/10^-2_distribution_false_negative.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/10^-2_distribution_false_positive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/10^-2_distribution_true_negatives.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/10^-2_distribution_true_positive.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/confusion_matrix_0.0_1e-08.png")
```

---

### Binary stoat covar VCF

```{r binary-vcf-covar}

# Execute verification for binary VCF
binary_output <- run_verify_truth(
  freq_file = file_list$binary_freq,
  pvalue_file = file_list$binary_covar_vcf,
  paths_file = file_list$binary_snarl,
  flag = " -c ",
  output_dir = "../binary_covar_output"
)

cat(binary_output, sep = "\n")

df_binary_covar_vcf <- read_stoat(file_list$binary_covar_vcf)

# Plots
histogram_plot(df=df_binary_covar_vcf, subtitle="Binary covar [stoat vcf]", "P", "P_ADJUSTED")
qq_plot(df_binary_covar_vcf, "P", subtitle="Binary covar [stoat vcf]")

manhattan_plot(df_binary_covar_vcf, subtitle="on Binary covar [stoat vcf]", "P", "P_ADJUSTED")
volcano_plot(df_binary_covar_vcf, subtitle="Binary covar [stoat vcf]")
```

```{r show-plot-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/10^-2_distribution_false_negative.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/10^-2_distribution_false_positive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/10^-2_distribution_true_negatives.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/10^-2_distribution_true_positive.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/confusion_matrix_0.0_1e-08.png")
```

---

### Binary stoat GRAPH

```{r binary-graph}
binary_output <- run_verify_truth(
  freq_file = file_list$binary_freq,
  pvalue_file = file_list$binary_graph,
  paths_file = file_list$binary_snarl,
  flag = " -b ",
  output_dir = "../binary_graph_output"
)

cat(binary_output, sep = "\n")

df_binary_graph <- read_stoat(file_list$binary_graph)

# Plots
histogram_plot(df=df_binary_graph, subtitle="Binary [stoat graph]", "P_FISHER", "P_CHI2", "P_ADJUSTED")
qq_plot(df_binary_graph, "P_FISHER", subtitle="Binary [stoat graph]")
qq_plot(df_binary_graph, "P_CHI2", subtitle="Binary [stoat graph]")

manhattan_plot(df_binary_graph, subtitle="on Binary [stoat graph]", "P_CHI2", "P_FISHER", "P_ADJUSTED")
```

```{r show-plot-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/output_pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/output10^-2_distribution_false_negative.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/output10^-2_distribution_false_positive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/output10^-2_distribution_true_negatives.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/output10^-2_distribution_true_positive.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/binary_scatter_plot_graph.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/binary_histo_plot_graph.png")
```

### Compare stoat graph vs stoat vcf binary output

```{r binary-graph}
# Compare each columns by matching SNARL
# Merge the data frames by SNARL
merged_df <- merge(df_binary_vcf, df_binary_graph, by = "SNARL", suffixes = c("_df1", "_df2"))

# Get the list of columns to compare (excluding SNARL)
columns_to_compare <- setdiff(names(df1), "SNARL")

# Initialize a named vector to store number of differing rows per column
column_diff_counts <- setNames(integer(length(columns_to_compare)), columns_to_compare)

# Loop through each column and count differing rows
for (col in columns_to_compare) {
  col1 <- paste0(col, "_df1")
  col2 <- paste0(col, "_df2")
  
  # Count where values differ (using `!=` and NA-safe logic)
  diffs <- merged_df[[col1]] != merged_df[[col2]]
  
  # Handle NAs: count rows where one is NA and the other is not, or values differ
  diffs[is.na(diffs)] <- xor(is.na(merged_df[[col1]]), is.na(merged_df[[col2]]))[is.na(diffs)]
  
  column_diff_counts[col] <- sum(diffs, na.rm = TRUE)
}

# Convert to data frame for pretty output
result <- data.frame(Column = names(column_diff_counts),
                     Num_Different_Rows = as.integer(column_diff_counts))

# Print result
print(result)

# SNARLs only in one file
only_in_df1 <- df_joined %>%
  filter(!is.na(START_POS_df1) & is.na(START_POS_df2)) %>%
  select(SNARL)

only_in_df2 <- df_joined %>%
  filter(is.na(START_POS_df1) & !is.na(START_POS_df2)) %>%
  select(SNARL)

cat("\n SNARL only in df1:\n")
print(only_in_df1)

cat("\n SNARL only in df2:\n")
print(only_in_df2)
```

---

### Quantitative stoat VCF

```{r quantitative-vcf}

# Execute verification for quantitative VCF
quantitative_output <- run_verify_truth(
  freq_file = file_list$quantitative_freq,
  pvalue_file = file_list$quantitative_vcf,
  paths_file = file_list$quantitative_snarl,
  flag = " -q ",
  output_dir = "../quantitative_output"
)

cat(quantitative_output, sep = "\n")

df_quantitative_vcf <- read_stoat(file_list$quantitative_vcf)

# ---- Plots ----
histogram_plot(df=df_quantitative_vcf, subtitle="Quantitative [stoat vcf]", "P", "P_ADJUSTED")
qq_plot(df_quantitative_vcf, "P", subtitle="Quantitative [stoat vcf]")

manhattan_plot(df_quantitative_vcf, subtitle="on Quantitative [stoat vcf]", "P", "P_ADJUSTED")
volcano_plot(df_quantitative_vcf, subtitle="Quantitative [stoat vcf]")
rsq_plot(df_quantitative_vcf, subtitle="Quantitative [stoat vcf]")
```

```{r show-plot-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/10^-2_distribution_false_negative.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/10^-2_distribution_false_positive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/10^-2_distribution_true_negatives.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/10^-2_distribution_true_positive.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/confusion_matrix_0.0_1e-08.png")
```

---

### Quantitative covar stoat VCF

```{r quantitative-covar-vcf}

# Execute verification for quantitative VCF
quantitative_output <- run_verify_truth(
  freq_file = file_list$quantitative_freq,
  pvalue_file = file_list$quantitative_covar_vcf,
  paths_file = file_list$quantitative_snarl,
  flag = " -q ",
  output_dir = "../quantitative_covar_output"
)

cat(quantitative_output, sep = "\n")

df_quantitative_covar_vcf <- read_stoat(file_list$quantitative_covar_vcf)

# ---- Plots ----
histogram_plot(df=df_quantitative_covar_vcf, subtitle="Quantitative covar [stoat vcf]", "P", "P_ADJUSTED")
qq_plot(df_quantitative_covar_vcf, "P", subtitle="Quantitative covar [stoat vcf]")

manhattan_plot(df_quantitative_covar_vcf, subtitle="On Quantitative covar [stoat vcf]", "P", "P_ADJUSTED")
volcano_plot(df_quantitative_covar_vcf, subtitle="Quantitative covar [stoat vcf]")
rsq_plot(df_quantitative_covar_vcf, subtitle="Quantitative covar [stoat vcf]")
```

```{r show-plot-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/10^-2_distribution_false_negative.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/10^-2_distribution_false_positive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/10^-2_distribution_true_negatives.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/10^-2_distribution_true_positive.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/confusion_matrix_0.0_1e-08.png")
```

---

### eQTL stoat VCF

```{r eqtl-vcf}
df_eqtl_vcf <- read_stoat(file_list$eqtl_vcf)

# ---- Plots ----
histogram_plot(df=df_eqtl_vcf, subtitle="Eqtl [stoat vcf]", "P", "P_ADJUSTED")
qq_plot(df_eqtl_vcf, "P", subtitle="Eqtl [stoat vcf]")

manhattan_plot(df_eqtl_vcf, subtitle="On Eqtl [stoat vcf]", "P_ADJUSTED", "P")
volcano_plot(df_eqtl_vcf, subtitle="Eqtl [stoat vcf]")
rsq_plot(df_eqtl_vcf, subtitle="Eqtl [stoat vcf]")
```

---

### eQTL covar stoat VCF

```{r eqtl-covar-vcf}
df_eqtl_covar_vcf <- read_stoat(file_list$eqtl_covar_vcf)

# ---- Plots ----
histogram_plot(df=df_eqtl_covar_vcf, subtitle="Eqtl covar [stoat vcf]", "P", "P_ADJUSTED")
qq_plot(df_eqtl_covar_vcf, "P", subtitle="Eqtl covar [stoat vcf]")

manhattan_plot(df_eqtl_covar_vcf, subtitle="with P Eqtl covar [stoat vcf]", "P", "P_ADJUSTED")
volcano_plot(df_eqtl_covar_vcf, subtitle="Eqtl covar [stoat vcf]")
rsq_plot(df_eqtl_covar_vcf, subtitle="Eqtl covar [stoat vcf]")
```
