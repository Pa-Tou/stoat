---
title: "Stoat Report (08/2025)"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    df_print: paged
params:
  run_mode: "html"
---

# Stoat in a nutshell

STOAT is a versatile GWAS (Genome-Wide Association Study) tool designed to work with 
pangenome graphs.

It supports binary phenotypes both with and without covariates: 
using Fisher’s exact test or Chi-squared test when no covariates are present, 
and logistic regression when covariates are included. 

For quantitative traits, STOAT performs linear regression, again with or without covariates. 
Additionally, it supports eQTL analysis, enabling association testing between
genetic variants and gene expression levels. 

It containt 2 modes :

* VCF : that will take VCF file in input and test snarl variant in it
* Graph : that will test snarl directly on the pangenome graph

## Stoat version 0.2.0 (08/2025)

---

* **Stoat**:

  * *Cartoon Update*: Added stoat graph (working progress).
  * Unified output format (`position`, `snarl_id`, `type`).

* **Stoat VCF**:

  * *Linear Regression*: Corrected near-perfect collinearity case by merging identical columns.
  * *Logistic Regression*: Corrected output format.
  * *Other Fixes*:

    * Fixed snarl paths parsing.
    * Fixed eQTL file format parsing (handles cases with large handlegraphs).

* **Stoat Graph**:

  * ...

---

```{r stoat-rep-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/plots/stoat_representation.png")
```

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)
library(readr)
library(dplyr)
library(tidyr)
library(CMplot)
library(stringr)

# utils::globalVariables(c("Expected", "Observed"))

# ---- File paths ----
file_list <- list(
  binary_snarl = "/home/mbagarre/Bureau/stoat/output_binary/snarl_analyse.tsv",
  binary_freq = "/home/mbagarre/Bureau/stoat/data/binary/pg.snarls.freq.tsv",
  binary_vcf = "/home/mbagarre/Bureau/stoat/output_binary/binary_table_vcf.tsv",
  binary_covar_vcf = "/home/mbagarre/Bureau/stoat/output_binary_covar/binary_table_vcf.tsv",

  quantitative_snarl = "/home/mbagarre/Bureau/stoat/output_quantitative/snarl_analyse.tsv",
  quantitative_freq = "/home/mbagarre/Bureau/stoat/data/quantitative/pg.snarls.freq.tsv",
  quantitative_vcf = "/home/mbagarre/Bureau/stoat/output_quantitative/quantitative_table_vcf.tsv",
  quantitative_covar_vcf = "/home/mbagarre/Bureau/stoat/output_quantitative_covar/quantitative_table_vcf.tsv",

  eqtl_snarl = "/home/mbagarre/Bureau/stoat/output_eqtl/snarl_analyse.tsv",
  eqtl_freq = "/home/mbagarre/Bureau/stoat/data/eqtl/pg.snarls.freq.tsv",
  eqtl_vcf = "/home/mbagarre/Bureau/stoat/output_eqtl/eqtl_table_vcf.tsv",
  eqtl_covar_vcf = "/home/mbagarre/Bureau/stoat/output_eqtl_covar/eqtl_table_vcf.tsv",

  binary_graph = "/home/mbagarre/Bureau/stoat/output_binary_graph/binary_table_graph.tsv"
)

# ---- Helper functions ----

# Read and clean table
read_stoat <- function(path) {
  df <- read_tsv(path, show_col_types = FALSE)
  if ("#CHR" %in% names(df)) names(df)[names(df) == "#CHR"] <- "CHR"
  if ("START_POS" %in% names(df) && !"POS" %in% names(df)) df$POS <- df$START_POS
  return(df)
}

# QQ plot with customizable column and subtitle
qq_plot <- function(df, col, subtitle = "") {
  if (!col %in% names(df)) return(NULL)

  pvec <- df[[col]]
  observed <- sort(pvec[!is.na(pvec)])
  expected <- -log10(ppoints(length(observed)))
  observed_log <- -log10(observed)
  data <- data.frame(Expected = expected, Observed = observed_log)
  
  ggplot(data, aes(x = Expected, y = Observed)) +
    geom_point(size = 1, alpha = 0.5) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
    labs(
      title = paste("QQ Plot of", col, subtitle),
      x = "Expected -log10(P)", y = "Observed -log10(P)"
    ) +
    theme_bw()
}

manhattan_plot <- function(df, subtitle = "", ...) {
  p_cols <- c(...)
  
  if (!all(c("CHR", "POS") %in% names(df))) {
    message("Skipping Manhattan plot: missing required columns 'CHR' or 'POS'.")
    return(NULL)
  }
  
  # If no P columns specified, default to "P" if exists
  if (length(p_cols) == 0) {
    if ("P" %in% names(df)) {
      p_cols <- "P"
    } else {
      message("No P-value column specified or found. Skipping plot.")
      return(NULL)
    }
  }
  
  # Convert CHR to numeric for plotting
  df$CHR_numeric <- as.numeric(as.factor(df$CHR))
  
  # Keep only relevant columns
  df_plot <- df %>%
    select(CHR_numeric, POS, all_of(p_cols)) %>%
    pivot_longer(cols = all_of(p_cols), names_to = "P_column", values_to = "P") %>%
    filter(!is.na(P))
  
  # Plot
  ggplot(df_plot, aes(x = POS, y = -log10(P), color = P_column)) +
    geom_point(alpha = 0.6) +
    theme_bw() +
    labs(
      title = paste("Manhattan plot", subtitle),
      x = "Position (BP)",
      y = "-log10(P)",
      color = "P-value column"
    )
}

# Volcano plot
volcano_plot <- function(df, p_col = "P", beta_col = "BETA", 
                         title = "Volcano Plot Beta vs P-value", subtitle = NULL, 
                         log_y = TRUE, point_alpha = 0.6, point_color = "blue") {
  
  # Check required columns
  if (!all(c(beta_col, p_col) %in% names(df))) {
    message(sprintf("Skipping Volcano plot: '%s' or '%s' not found.", beta_col, p_col))
    return(NULL)
  }
  
  # Compute -log10(P)
  df$logP <- -log10(df[[p_col]])
  
  # Plot
  p <- ggplot(df, aes_string(x = beta_col, y = "logP")) +
    geom_point(alpha = point_alpha, color = point_color) +
    theme_bw() +
    labs(
      title = title,
      subtitle = subtitle,
      x = paste("Effect Size (", beta_col, ")", sep = ""),
      y = paste("-log10(", p_col, ")", sep = "")
    )
  
  if (log_y) {
    p <- p + scale_y_continuous(trans = "log10")
  }
  
  return(p)
}

# RSQUARE vs BETA plot
rsq_plot <- function(df, rsq_col = "RSQUARE", beta_col = "BETA", 
                     title = "Effect Size vs RSQUARE", subtitle = NULL, 
                     log_x = FALSE, log_y = FALSE, point_alpha = 0.6, point_color = "blue") {
  
  # Check required columns
  if (!all(c(rsq_col, beta_col) %in% names(df))) {
    message(sprintf("Skipping RSQ plot: '%s' or '%s' not found.", rsq_col, beta_col))
    return(NULL)
  }
  
  # Plot
  p <- ggplot(df, aes_string(x = rsq_col, y = beta_col)) +
    geom_point(alpha = point_alpha, color = point_color) +
    theme_bw() +
    labs(
      title = title,
      subtitle = subtitle,
      x = rsq_col,
      y = beta_col
    )
  
  if (log_x) p <- p + scale_x_continuous(trans = "log10")
  if (log_y) p <- p + scale_y_continuous(trans = "log10")
  
  return(p)
}

# Histogram of P-values with custom columns and subtitle
histogram_plot <- function(df, subtitle = "", ...) {
  cols <- c(...)
  if (!all(cols %in% names(df))) return(NULL)

  df_long <- df %>%
    select(all_of(cols)) %>%
    pivot_longer(cols = everything(), names_to = "Type", values_to = "PValue")
  
  ggplot(df_long, aes(x = PValue, fill = Type)) +
    geom_histogram(alpha = 0.6, position = "dodge", bins = 50) +
    theme_bw() +
    labs(
      title = paste("Distribution of P-values", subtitle),
      x = "P-value", y = "Count"
    ) +
    scale_fill_brewer(palette = "Set1")
}

# ---- Run Python verification truth VCF ----
run_verify_truth <- function(freq_file, pvalue_file, paths_file, flag, output_dir) {
  cmd <- paste(
    "python3 /home/mbagarre/Bureau/stoat/tests/scripts/verify_truth.py",
    "--freq", freq_file,
    "--p_value", pvalue_file,
    "--paths", paths_file,
    flag,
    "--output", output_dir
  )
  output <- system(cmd, intern = TRUE)
  return(output)
}

run_scatter_plot_graph <- function(input, output) {
  cmd <- paste(
    "python3 /home/mbagarre/Bureau/stoat/tests/scripts/plot_scatter.py",
    input,
    output
  )
  output <- system(cmd, intern = TRUE)
  return(output)
}

run_histo_plot_graph <- function(input, output) {
  cmd <- paste(
    "python3 /home/mbagarre/Bureau/stoat/tests/scripts/plot_histogram.py",
    input,
    output
  )
  output <- system(cmd, intern = TRUE)
  return(output)
}
```

---

## Simulation Description

We constructed three simulated datasets: **binary**, **quantitative**, and **eQTL**.

The binary and quantitative simulations each include their own pangenome graph representing a single chromosome, incorporating various types of variation, such as SNPs, INDELs, and complex variants. Despite the different variations, the graph structure—based on a fork pattern—remains consistent across all simulations.

A fork structure is defined as a boundary snarl with exactly two paths, which can themselves contain nested forks (see fork representation below).

```{r show-fork-png, echo=FALSE, out.width="20%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/plots/fork.png")
```

Once the pangenome graph was constructed, we simulated individual haplotypes by generating sample genomes that traverse different paths within the graph. To introduce phenotype-genotype relationships, we assigned each haplotype a binary or quantitative phenotype according to specific simulation rules.

```{r show-haplotype-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/plots/haplotype.png")
```

The eQTL simulation differs in that it includes **10 chromosomes**, but no pangenome graph is constructed. Instead, we directly simulate the path-snarl file required by STOAT, and the variations consist only of simple SNPs.

---

```{r results='asis', echo=FALSE}
library(knitr)

# Create the data frame
df <- data.frame(
  Type = c("Binary", "Quantitative", "eqtl"),
  `Number of samples` = c(200, 200, 200),
  `Number of variant type (SNP/INDEL/COMPLEX)` = c("2444/446/158", "2478/382/138", "200000/0/0"),
  `Number of snarl/paths` = c("1524/3048", "1499/2998", "100000/200000"),
  check.names = FALSE
)

# Print as R Markdown table
kable(df, format = "markdown", align = "c")
```

---

### Binary Simulation

200 samples were divided into two cohorts (100 cases and 100 controls), each corresponding to a different phenotypic state containing 1,000 variations. Each group had a correlated probability of traversing a specific path within each snarl. This probability (e.g., 50/50) could be equal between the two cohorts or skewed in favor of one group (e.g., 20/80), simulating an association between variation and phenotype.

---

### Quantitative Simulation

Similar to the binary simulation, 200 samples were divided into two cohorts, with each group having a correlated probability of traversing specific paths within snarls. In this case, an additional probability factor was introduced so that the likelihood of passing through a given path depends on the individual’s phenotype value.

---

### eQTL Simulation

In this simulation, we generated 200 samples with 200,000 SNPs and 100 genes. All variants were generated randomly, meaning no significant associations were introduced. The goal was to create a simple simulation to test STOAT’s VCF-based eQTL pipeline.

---

### Covariate Simulation

Covariates were simulated based on the phenotype, except for sex. They include **SEX**, **PC1**, **PC2**, and **PC3**. The SEX covariate is randomly assigned as male or female, while the other PCs are simulated from a normal distribution.

---

### Verifying the Truth Simulation Description

#### Frequency File Description

The **binary** and **quantitative** simulations produce a file containing the following elements:

* The **frequency probability (freq)** of a haplotype, depending on its group, to follow a specific path or edge in a fork.
* The **group** associated with each frequency.
* The **start** and **end** nodes of the fork.

If two groups have identical probabilities on the same edge, it may appear significant by chance but will be treated as **non-significant** in downstream analysis. Conversely, a difference in frequency between the two groups, even if small, is treated as **significant**.

**Example `freq` file:**

```
start_node	next_node	group	freq
2	        3	        0	    0.53
2	        3	        1	    0.53
2	        4	        0	    0.47
2	        4	        1	    0.47
```

#### Computing STOAT Output with the Frequency File

To assess whether a snarl is correctly identified as significant, we merge the snarl’s path information with the frequency probabilities from the `freq` file.

A **correct match** is a snarl that contains **both** start/end node pairs in **two separate paths** (one for each group).

---

### Graph Information

* A snarl is considered **true** if it contains a fork where **at least one edge** shows a frequency difference between the two groups.
* A snarl is considered **positive** if its **P-value is below 0.01**.
* The **p-value** used for verification in the binary simulation is the **CHI2 p-value**.
* The size of the dots in the p-value vs. simulated effect graphs is proportional to the number of haplotypes passing through the snarl.

---

### Binary stoat VCF

```{r binary-vcf, echo=FALSE}

# Execute verification for binary VCF
binary_output <- run_verify_truth(
  freq_file = file_list$binary_freq,
  pvalue_file = file_list$binary_vcf,
  paths_file = file_list$binary_snarl,
  flag = " -b ",
  output_dir = "../binary_output"
)

cat(binary_output, sep = "\n")

df_binary_vcf <- read_stoat(file_list$binary_vcf)

# Plots
histogram_plot(df=df_binary_vcf, subtitle="Binary [stoat vcf]", "P_FISHER", "P_CHI2")
qq_plot(df_binary_vcf, "P_FISHER", subtitle="Binary [stoat vcf]")
qq_plot(df_binary_vcf, "P_CHI2", subtitle="Binary [stoat vcf]")

#manhattan_plot(df_binary_vcf, subtitle="Binary [stoat vcf]", "P_CHI2", "P_FISHER", "P_ADJUSTED")
```

```{r show-plot-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/10^-2_distribution_fn_tp.png")
# knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/10^-2_distribution_false_positive.png")
# knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/10^-2_distribution_true_negatives.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_output/confusion_matrix_0.0_1e-08.png")
```

---

### Binary stoat covar VCF

```{r binary-vcf-covar, echo=FALSE}

# Execute verification for binary VCF
binary_output <- run_verify_truth(
  freq_file = file_list$binary_freq,
  pvalue_file = file_list$binary_covar_vcf,
  paths_file = file_list$binary_snarl,
  flag = " -c ",
  output_dir = "../binary_covar_output"
)

cat(binary_output, sep = "\n")

df_binary_covar_vcf <- read_stoat(file_list$binary_covar_vcf)

# Plots
histogram_plot(df=df_binary_covar_vcf, subtitle="Binary covar [stoat vcf]", "P")
qq_plot(df_binary_covar_vcf, "P", subtitle="Binary covar [stoat vcf]")

#manhattan_plot(df_binary_covar_vcf, subtitle="on Binary covar [stoat vcf]", "P", "P_ADJUSTED")
#volcano_plot(df_binary_covar_vcf, subtitle="Binary covar [stoat vcf]")
```

The reason why the percentage of paths tested isn’t 100% can be explained by the fact that we filter snarls based on a threshold for the number of haplotypes and the number of samples present in each snarl.

```{r show-plot1-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/10^-2_distribution_fn_tp.png")
# knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/10^-2_distribution_false_positive.png")
# knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/10^-2_distribution_true_negatives.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_covar_output/confusion_matrix_0.0_1e-08.png")
```

---

### Binary stoat GRAPH

```{r binary-graph, echo=FALSE}
binary_output <- run_verify_truth(
  freq_file = file_list$binary_freq,
  pvalue_file = file_list$binary_graph,
  paths_file = file_list$binary_snarl,
  flag = " -b ",
  output_dir = "../binary_graph_output"
)

cat(binary_output, sep = "\n")

df_binary_graph <- read_stoat(file_list$binary_graph)

# Plots
histogram_plot(df=df_binary_graph, subtitle="Binary [stoat graph]", "P_FISHER", "P_CHI2")
qq_plot(df_binary_graph, "P_FISHER", subtitle="Binary [stoat graph]")
qq_plot(df_binary_graph, "P_CHI2", subtitle="Binary [stoat graph]")

#manhattan_plot(df_binary_graph, subtitle="on Binary [stoat graph]", "P_CHI2", "P_FISHER", "P_ADJUSTED")
```

```{r show-plot2-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/10^-2_distribution_fn_tp.png")
#knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/10^-2_distribution_false_positive.png")
#knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/10^-2_distribution_true_negatives.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/binary_graph_output/confusion_matrix_0.0_1e-08.png")
```

### Compare stoat graph vs stoat vcf binary output

```{r binary-graph2, echo=FALSE}
# Compare each columns by matching SNARL
# Merge the data frames by SNARL
merged_df <- merge(df_binary_vcf, df_binary_graph, by = "SNARL", suffixes = c("_df1", "_df2"))

# Get the list of columns to compare (excluding SNARL)
columns_to_compare <- setdiff(names(df_binary_vcf), "SNARL")

# Initialize a named vector to store number of differing rows per column
column_diff_counts <- setNames(integer(length(columns_to_compare)), columns_to_compare)

# Loop through each column and count differing rows
for (col in columns_to_compare) {
  col1 <- paste0(col, "_df1")
  col2 <- paste0(col, "_df2")
  
  # Count where values differ (using `!=` and NA-safe logic)
  diffs <- merged_df[[col1]] != merged_df[[col2]]
  
  # Handle NAs: count rows where one is NA and the other is not, or values differ
  diffs[is.na(diffs)] <- xor(is.na(merged_df[[col1]]), is.na(merged_df[[col2]]))[is.na(diffs)]
  
  column_diff_counts[col] <- sum(diffs, na.rm = TRUE)
}

# Convert to data frame for pretty output
result <- data.frame(Column = names(column_diff_counts),
                     Num_Different_Rows = as.integer(column_diff_counts))

# Print result
print(result)
```

This change can be explained because the stoat graph uses the 'ref' haplotype as the correct haplotype, whereas in the simulation it is not.

---

### Quantitative stoat VCF

```{r quantitative-vcf, echo=FALSE}

# Execute verification for quantitative VCF
quantitative_output <- run_verify_truth(
  freq_file = file_list$quantitative_freq,
  pvalue_file = file_list$quantitative_vcf,
  paths_file = file_list$quantitative_snarl,
  flag = " -q ",
  output_dir = "../quantitative_output"
)

cat(quantitative_output, sep = "\n")

df_quantitative_vcf <- read_stoat(file_list$quantitative_vcf)

# ---- Plots ----
histogram_plot(df=df_quantitative_vcf, subtitle="Quantitative [stoat vcf]", "P")
qq_plot(df_quantitative_vcf, "P", subtitle="Quantitative [stoat vcf]")

#manhattan_plot(df_quantitative_vcf, subtitle="on Quantitative [stoat vcf]", "P", "P_ADJUSTED")
#volcano_plot(df_quantitative_vcf, subtitle="Quantitative [stoat vcf]")
#rsq_plot(df_quantitative_vcf, subtitle="Quantitative [stoat vcf]")
```

```{r show-plot3-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/10^-2_distribution_fn_tp.png")
#knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/10^-2_distribution_false_positive.png")
#knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/10^-2_distribution_true_negatives.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_output/confusion_matrix_0.0_1e-08.png")
```

---

### Quantitative covar stoat VCF

```{r quantitative-covar-vcf, echo=FALSE}

# Execute verification for quantitative VCF
quantitative_output <- run_verify_truth(
  freq_file = file_list$quantitative_freq,
  pvalue_file = file_list$quantitative_covar_vcf,
  paths_file = file_list$quantitative_snarl,
  flag = " -q ",
  output_dir = "../quantitative_covar_output"
)

cat(quantitative_output, sep = "\n")

df_quantitative_covar_vcf <- read_stoat(file_list$quantitative_covar_vcf)

# ---- Plots ----
histogram_plot(df=df_quantitative_covar_vcf, subtitle="Quantitative covar [stoat vcf]", "P")
qq_plot(df_quantitative_covar_vcf, "P", subtitle="Quantitative covar [stoat vcf]")

#manhattan_plot(df_quantitative_covar_vcf, subtitle="On Quantitative covar [stoat vcf]", "P", "P_ADJUSTED")
#volcano_plot(df_quantitative_covar_vcf, subtitle="Quantitative covar [stoat vcf]")
#rsq_plot(df_quantitative_covar_vcf, subtitle="Quantitative covar [stoat vcf]")
```

```{r show-plot4-png, echo=FALSE, out.width="100%"}
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/pvalue_interactive.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/10^-2_distribution_fn_tp.png")
#knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/10^-2_distribution_false_positive.png")
#knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/10^-2_distribution_true_negatives.png")

knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/confusion_matrix_0.0_0.01.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/confusion_matrix_0.0_1e-05.png")
knitr::include_graphics("/home/mbagarre/Bureau/stoat/tests/quantitative_covar_output/confusion_matrix_0.0_1e-08.png")
```

---

### eQTL stoat VCF

```{r eqtl-vcf, echo=FALSE}
df_eqtl_vcf <- read_stoat(file_list$eqtl_vcf)

# ---- Plots ----
histogram_plot(df=df_eqtl_vcf, subtitle="Eqtl [stoat vcf]", "P")
qq_plot(df_eqtl_vcf, "P", subtitle="Eqtl [stoat vcf]")

#manhattan_plot(df_eqtl_vcf, subtitle="On Eqtl [stoat vcf]", "P_ADJUSTED", "P")
#volcano_plot(df_eqtl_vcf, subtitle="Eqtl [stoat vcf]")
#rsq_plot(df_eqtl_vcf, subtitle="Eqtl [stoat vcf]")
```

---

### eQTL covar stoat VCF

```{r eqtl-covar-vcf, echo=FALSE}
df_eqtl_covar_vcf <- read_stoat(file_list$eqtl_covar_vcf)

# ---- Plots ----
histogram_plot(df=df_eqtl_covar_vcf, subtitle="Eqtl covar [stoat vcf]", "P")
qq_plot(df_eqtl_covar_vcf, "P", subtitle="Eqtl covar [stoat vcf]")

#manhattan_plot(df_eqtl_covar_vcf, subtitle="with P Eqtl covar [stoat vcf]", "P", "P_ADJUSTED")
#volcano_plot(df_eqtl_covar_vcf, subtitle="Eqtl covar [stoat vcf]")
#rsq_plot(df_eqtl_covar_vcf, subtitle="Eqtl covar [stoat vcf]")
```
